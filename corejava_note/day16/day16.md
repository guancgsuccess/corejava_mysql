# 进程和线程

* 进程

  是执行中一段程序,即一旦程序被载入到内存中并且准备执行,它就是一个进程.进程是表示**资源分配**的基本概念.

  又是调度运行的基本单位,是系统的并发执行的单位.

* 线程

  单个进程中执行中每个任务就是一个线程.**线程是进程中执行运算的最小单位**

一个线程只能属于一个进程,但是一个进程中可以拥有多个线程.多线程处理就是允许一个进程中

在同一个时刻执行多个任务.进程是有独立的空间的.线程是共享进程中的资源.并且线程是轻量级的,进程是重量级的.线程的维护的成本会比进程的开销要小.



# 多任务操作系统

CPU可以同时处理多个进程.同时是宏观上的"同时".

CPU采用"分时分片"的模式来处理运行中的进程.



## 线程的实现方式

* 通过java.lang.Thread类
  * Thread();//系统会默认分配线程的名字,Thread-数字
  * Thread(String name);//创建线程的同时,给线程进行命名.
* 利用java.lang.Runnable接口对象来构建Thread线程对象
  * Thread(Runnable r);
  * Thread(Runnable r,String name)

### 方式

* 共享代码,不共享资源
  * 采用extends Thread - 定义非静态成员
  * Thread(Runnable r) - >传入俩个实现类即可
* 共享代码,共享资源
  * 采用extends Thread - 需要使用静态属性 - 类拥有,对象共享的
  * 采用实现Runnable接口 - 只new了一次- 非静态成员也就值初始了一次
* 不共享代码,不共享资源
* 不共享代码,共享资源



## Thread类常用的方法

* static Thread currentThread();//返回的就是当前正在执行的线程的对象的引用.

* String getName();//返回线程的名称

* void start();//启动线程 - 线程的启动真正的方法run方法只能被jvm去调用.

  ​		    //我们是不能手动调用run方法来启动一个线程的.

* void setName(String name);

* int  getPriority();//返回线程的优先级,默认的优先级都是5,线程的优先级1-10

* void setPriority(int i);//设置线程的优先级

* void setDaemon(boolean on);//如果为true,则代表是守护线程,否则是用户线程

* void join();//当前执行的线程会进入到阻塞状态,调用其他线程的join方法的时候,那么会执行其他线程,

  ​                  //当其他线程执行完毕之后,那么本线程才会继续执行.

* static void yield();//线程之间的礼让 - 暂停本线程,让其他线程先执行 - 不是100%礼让成功的.

## 守护线程

当我们启动类的时候,实际上JVM这个进程会在内存中启动俩个线程,一个就是我们的main方法 - 主线程.

还启动了一个后台守护线程 - GC线程.

我们的进程是什么时候可以退出了?

当后台只存在守护线程的时候,进程就可以退出了.



## 线程的状态

* 初始态

  ~~~java
  Thread t1 = new T1();
  ~~~

* 就绪态(可运行态)

  ~~~java
  t1.start();
  ~~~

* 运行态

  ~~~java
  底层由jvm去调用run方法,线程处于运行的过程中
  ~~~

* 阻塞态

  * 调用其他线程的join方法

  * 调用自己的yield方法

  * 调用sleep方法 

  * 调取获取键盘输入的时候.比如sc.nextInt()

    

  如何打破阻塞态:

  * 当其他线程调用join之后,其他线程运行完毕.
  * 并不是100%会礼让,当其他线程运行到礼让的时候,或者运行结束的时候.
  * 睡眠时间结束
  * 用户输入enter键之后

* 锁池

  是一种特殊的阻塞状态.

  当线程想要执行**同步代码**的时候,JVM会判断该线程是否拥有"**临界资源**"的"**锁标记**".

  如果拥有,则会进入到同步代码块去执行里面的代码,否则会进入到"临界资源"的对象的锁池当中.

* 等待队列

  是一种特殊的阻塞状态

  处于等待队列下的线程,自己是不会主动被JVM去调度的,需要其他线程唤醒.

  涉及到wait方法,**notifyAll**或者notify.当只有其他线程调用唤醒的方法的时候,那么jvm才会到等待队列中

  去调度里面的线程,并且是将线程从等待队列中拿出来放入到"锁池"中.



## 多线程的并发访问

在同一个时刻,多个线程对同一个资源进行访问操作.如果这个操作涉及到更新,修改,增加的话.

那么就容易造成数据的不一致.多线程并发访问的问题.

## synchronized关键字

用这个关键字来实现同步代码.有两种方式

* 同步方法 - 内同步 - 锁住整个方法 - 不推荐

  ~~~java
  public synchronized void test(){
      
  }
  ~~~

  

* 同步代码块 - 外同步 - 推荐使用的方式

  ~~~java
  public void test(){
      //...业务代码
      sychronized(临界资源对象1){
          
      }
      sychronized(临界资源对象2){
          
      }
      //
  }
  ~~~

  

## 线程的API

ArrayList和Vector

StringBuilder和StringBuffer

HashMap和TreeMap



# 死锁

概念:多个并发进程因为争夺系统资源而产生相互等待的现象. - "哲学家吃饭"

原理:当一组进程中的每个进程都在等待某个事件发生,而只有这组进程中的其他进程才能

​	触发这个事件,这就叫这组进程发生了死锁.

本质原因:

* 系统资源是有限
* 进程推进的顺序是不合理的.



## 必要条件

死锁产生的四个必要条件:

* 互斥 

  某种资源一次只允许一个进程访问.一旦资源被分配给了某个进程,那么其他进程将不能再访问.

  直到该进程访问结束.

* 占有且等待

  一个进程本身占有资源,同时还有资源未得到,正在等待其他进程释放该资源.

* 不可抢占

  别人已经占有了某项资源,你不能因为自己需要就抢过来.

* 循环等待

  存在一个进程链,使得每个进程都占有下一个进程所需要的一种资源.

四个条件都成立,那么必然会发生死锁.进程就无法继续进行



如何打破死锁?

打破上边任意一个条件.



## 问题域的产生

静态域容易造成死锁问题.



# 线程之间的通信

* wait() - 如果某个线程调用了wait方法,那么该线程会处于等待队列.

  下次如果希望继续执行的话,那么必须由其他线程唤醒.

* notify() - 唤醒等待队列上的单个线程

* notifyAll() - 唤醒等待队列上的所有的线程.

  **这些方法一定要出现在线程同步代码块中.**



案例:生产者和消费者

















